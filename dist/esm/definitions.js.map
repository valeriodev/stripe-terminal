{"version":3,"file":"definitions.js","sourceRoot":"","sources":["../../src/definitions.ts"],"names":[],"mappings":"AA6FA,cAAc,eAAe,CAAC;AAC9B,cAAc,eAAe,CAAC","sourcesContent":["import type { PluginListenerHandle } from '@capacitor/core';\n\nimport type { TerminalEventsEnum } from './events.enum';\nimport type {\n  TerminalConnectTypes,\n  UpdateTimeEstimate,\n  SimulateReaderUpdate,\n  SimulatedCardType,\n  BatteryStatus,\n  ReaderEvent,\n  ReaderDisplayMessage,\n  ReaderInputOption,\n  PaymentStatus,\n  DisconnectReason,\n  ConnectionStatus,\n  NetworkStatus,\n  LocationStatus,\n  DeviceType,\n} from './stripe.enum';\n\nexport type ReaderInterface = {\n  /**\n   * The unique serial number is primary identifier inner plugin.\n   */\n  serialNumber: string;\n\n  label: string;\n  batteryLevel: number;\n  batteryStatus: BatteryStatus;\n  simulated: boolean;\n  id: number;\n  availableUpdate: ReaderSoftwareUpdateInterface | undefined;\n  locationId: string;\n  ipAddress: string;\n  status: NetworkStatus;\n  location: LocationInterface | undefined;\n  locationStatus: LocationStatus;\n  deviceType: DeviceType;\n  deviceSoftwareVersion: string | null;\n\n  /**\n   * iOS Only properties. These properties are not available on Android.\n   */\n  isCharging: number;\n\n  /**\n   * Android Only properties. These properties are not available on iOS.\n   */\n  baseUrl: string;\n  bootloaderVersion: string;\n  configVersion: string;\n  emvKeyProfileId: string;\n  firmwareVersion: string;\n  hardwareVersion: string;\n  macKeyProfileId: string;\n  pinKeyProfileId: string;\n  trackKeyProfileId: string;\n  settingsVersion: string;\n  pinKeysetId: string;\n};\nexport type LocationInterface = {\n  id: string;\n  displayName: string;\n  address: {\n    city: string;\n    country: string;\n    postalCode: string;\n    line1: string;\n    line2: string;\n    state: string;\n  };\n  ipAddress: string;\n};\n\nexport type ReaderSoftwareUpdateInterface = {\n  deviceSoftwareVersion: string;\n  estimatedUpdateTime: UpdateTimeEstimate;\n  requiredAt: number;\n};\n\nexport type CartLineItem = {\n  displayName: string;\n  quantity: number;\n  amount: number;\n};\n\nexport type Cart = {\n  currency: string;\n  tax: number;\n  total: number;\n  lineItems: CartLineItem[];\n};\n\nexport * from './events.enum';\nexport * from './stripe.enum';\nexport interface StripeTerminalPlugin {\n  initialize(options: { tokenProviderEndpoint?: string; isTest: boolean }): Promise<void>;\n  discoverReaders(options: { type: TerminalConnectTypes; locationId?: string }): Promise<{\n    readers: ReaderInterface[];\n  }>;\n  setConnectionToken(options: { token: string }): Promise<void>;\n  /**\n   * [*Stripe docs reference*](https://stripe.dev/stripe-terminal-android/external/com.stripe.stripeterminal.external.models/-simulator-configuration/index.html)\n   */\n  setSimulatorConfiguration(options: {\n    update?: SimulateReaderUpdate;\n    simulatedCard?: SimulatedCardType;\n    simulatedTipAmount?: number;\n  }): Promise<void>;\n\n  /**\n   * @param options.autoReconnectOnUnexpectedDisconnect If true, the SDK will automatically attempt to reconnect to the reader. default is false.\n   */\n  connectReader(options: {\n    reader: ReaderInterface;\n    autoReconnectOnUnexpectedDisconnect?: boolean;\n\n    /**\n     * iOS and LocalMobileReader only. Android needs to be set to PaymentIntent only.\n     */\n    merchantDisplayName?: string;\n\n    /**\n     * iOS and LocalMobileReader only. Android needs to be set to PaymentIntent only.\n     * The Stripe account ID for which these funds are intended.\n     */\n    onBehalfOf?: string;\n  }): Promise<void>;\n  getConnectedReader(): Promise<{ reader: ReaderInterface | null }>;\n  disconnectReader(): Promise<void>;\n  cancelDiscoverReaders(): Promise<void>;\n  collectPaymentMethod(options: { paymentIntent: string }): Promise<void>;\n  cancelCollectPaymentMethod(): Promise<void>;\n  confirmPaymentIntent(): Promise<void>;\n  installAvailableUpdate(): Promise<void>;\n  cancelInstallUpdate(): Promise<void>;\n  setReaderDisplay(options: Cart): Promise<void>;\n  clearReaderDisplay(): Promise<void>;\n  rebootReader(): Promise<void>;\n  cancelReaderReconnection(): Promise<void>;\n\n  addListener(eventName: TerminalEventsEnum.Loaded, listenerFunc: () => void): Promise<PluginListenerHandle>;\n\n  addListener(\n    eventName: TerminalEventsEnum.RequestedConnectionToken,\n    listenerFunc: () => void,\n  ): Promise<PluginListenerHandle>;\n\n  addListener(\n    eventName: TerminalEventsEnum.DiscoveredReaders,\n    listenerFunc: ({ readers }: { readers: ReaderInterface[] }) => void,\n  ): Promise<PluginListenerHandle>;\n\n  addListener(eventName: TerminalEventsEnum.ConnectedReader, listenerFunc: () => void): Promise<PluginListenerHandle>;\n\n  /**\n   * Emitted when the reader is disconnected, either in response to [`disconnectReader()`](#disconnectreader)\n   * or some connection error.\n   *\n   * For all reader types, this is emitted in response to [`disconnectReader()`](#disconnectreader)\n   * without a `reason` property.\n   *\n   * For Bluetooth and USB readers, this is emitted with a `reason` property when the reader disconnects.\n   *\n   * **Note:** For Bluetooth and USB readers, when you call [`disconnectReader()`](#disconnectreader), this event\n   * will be emitted twice: one without a `reason` in acknowledgement of your call, and again with a `reason` when the reader\n   * finishes disconnecting.\n   */\n  addListener(\n    eventName: TerminalEventsEnum.DisconnectedReader,\n    listenerFunc: ({ reason }: { reason?: DisconnectReason }) => void,\n  ): Promise<PluginListenerHandle>;\n\n  /**\n   * Emitted when the Terminal's connection status changed.\n   *\n   * Note: You should *not* use this method to detect when a reader unexpectedly disconnects from your app,\n   * as it cannot be used to accurately distinguish between expected and unexpected disconnect events.\n   *\n   * To detect unexpected disconnects (e.g. to automatically notify your user), you should instead use\n   * the UnexpectedReaderDisconnect event.\n   *\n   * [*Stripe docs reference*](https://stripe.dev/stripe-terminal-android/external/com.stripe.stripeterminal.external.callable/-terminal-listener/on-connection-status-change.html)\n   */\n  addListener(\n    eventName: TerminalEventsEnum.ConnectionStatusChange,\n    listenerFunc: ({ status }: { status: ConnectionStatus }) => void,\n  ): Promise<PluginListenerHandle>;\n\n  /**\n   * The Terminal disconnected unexpectedly from the reader.\n   *\n   * In your implementation of this method, you may want to notify your user that the reader disconnected.\n   * You may also call [`discoverReaders()`](#discoverreaders) to begin scanning for readers, and attempt\n   * to automatically reconnect to the disconnected reader. Be sure to either set a timeout or make it\n   * possible to cancel calls to `discoverReaders()`\n   *\n   * When connected to a Bluetooth or USB reader, you can get more information about the disconnect by\n   * implementing the DisconnectedReader event.\n   *\n   * [*Stripe docs reference*](https://stripe.dev/stripe-terminal-android/external/com.stripe.stripeterminal.external.callable/-terminal-listener/on-unexpected-reader-disconnect.html)\n   */\n  addListener(\n    eventName: TerminalEventsEnum.UnexpectedReaderDisconnect,\n    listenerFunc: ({ reader }: { reader: ReaderInterface }) => void,\n  ): Promise<PluginListenerHandle>;\n\n  addListener(\n    eventName: TerminalEventsEnum.ConfirmedPaymentIntent,\n    listenerFunc: () => void,\n  ): Promise<PluginListenerHandle>;\n\n  addListener(\n    eventName: TerminalEventsEnum.CollectedPaymentIntent,\n    listenerFunc: () => void,\n  ): Promise<PluginListenerHandle>;\n\n  /**\n   * Emitted when [`cancelCollectPaymentMethod()`](#cancelcollectpaymentmethod) is called and succeeds.\n   * The Promise returned by `cancelCollectPaymentMethod()` will also be resolved.\n   */\n  addListener(eventName: TerminalEventsEnum.Canceled, listenerFunc: () => void): Promise<PluginListenerHandle>;\n\n  /**\n   * Emitted when either [`collectPaymentMethod()`](#collectpaymentmethod) or [`confirmPaymentIntent()`](#confirmpaymentintent)\n   * fails. The Promise returned by the relevant call will also be rejected.\n   */\n  addListener(\n    eventName: TerminalEventsEnum.Failed,\n    listenerFunc: (info: { message: string; code?: string; declineCode?: string }) => void,\n  ): Promise<PluginListenerHandle>;\n\n  /**\n   * Emitted when a software update is available for the connected reader.\n   */\n  addListener(\n    eventName: TerminalEventsEnum.ReportAvailableUpdate,\n    listenerFunc: ({ update }: { update: ReaderSoftwareUpdateInterface }) => void,\n  ): Promise<PluginListenerHandle>;\n\n  /**\n   * **Only applicable to Bluetooth and USB readers.**\n   *\n   * Emitted when the connected reader begins installing a software update.\n   * If a mandatory software update is available when a reader first connects, that update is\n   * automatically installed. The update will be installed before ConnectedReader is emitted and\n   * before the Promise returned by [`connectReader()`](#connectreader) resolves.\n   * In this case, you will receive this sequence of events:\n   *\n   * 1. StartInstallingUpdate\n   * 2. ReaderSoftwareUpdateProgress (repeatedly)\n   * 3. FinishInstallingUpdates\n   * 4. ConnectedReader\n   * 5. `connectReader()` Promise resolves\n   *\n   * Your app should show UI to the user indiciating that a software update is being installed\n   * to explain why connecting is taking longer than usual.\n   *\n   * [*Stripe docs reference*](https://stripe.dev/stripe-terminal-android/external/com.stripe.stripeterminal.external.callable/-reader-listener/on-start-installing-update.html)\n   */\n  addListener(\n    eventName: TerminalEventsEnum.StartInstallingUpdate,\n    listenerFunc: ({ update }: { update: ReaderSoftwareUpdateInterface }) => void,\n  ): Promise<PluginListenerHandle>;\n\n  /**\n   * **Only applicable to Bluetooth and USB readers.**\n   *\n   * Emitted periodically while reader software is updating to inform of the installation progress.\n   * `progress` is a float between 0 and 1.\n   *\n   * [*Stripe docs reference*](https://stripe.dev/stripe-terminal-android/external/com.stripe.stripeterminal.external.callable/-reader-listener/on-report-reader-software-update-progress.html)\n   */\n  addListener(\n    eventName: TerminalEventsEnum.ReaderSoftwareUpdateProgress,\n    listenerFunc: ({ progress }: { progress: number }) => void,\n  ): Promise<PluginListenerHandle>;\n\n  /**\n   * **Only applicable to Bluetooth and USB readers.**\n   *\n   * [*Stripe docs reference*](https://stripe.dev/stripe-terminal-android/external/com.stripe.stripeterminal.external.callable/-reader-listener/on-finish-installing-update.html)\n   */\n  addListener(\n    eventName: TerminalEventsEnum.FinishInstallingUpdate,\n    listenerFunc: (\n      args:\n        | {\n            update: ReaderSoftwareUpdateInterface;\n          }\n        | {\n            error: string;\n          },\n    ) => void,\n  ): Promise<PluginListenerHandle>;\n\n  /**\n   * **Only applicable to Bluetooth and USB readers.**\n   *\n   * Emitted upon connection and every 10 minutes.\n   *\n   * [*Stripe docs reference*](https://stripe.dev/stripe-terminal-android/external/com.stripe.stripeterminal.external.callable/-reader-listener/on-battery-level-update.html)\n   */\n  addListener(\n    eventName: TerminalEventsEnum.BatteryLevel,\n    listenerFunc: ({ level, charging, status }: { level: number; charging: boolean; status: BatteryStatus }) => void,\n  ): Promise<PluginListenerHandle>;\n\n  /**\n   * **Only applicable to Bluetooth and USB readers.**\n   *\n   * [*Stripe docs reference*](https://stripe.dev/stripe-terminal-android/external/com.stripe.stripeterminal.external.callable/-reader-listenable/on-report-reader-event.html)\n   */\n  addListener(\n    eventName: TerminalEventsEnum.ReaderEvent,\n    listenerFunc: ({ event }: { event: ReaderEvent }) => void,\n  ): Promise<PluginListenerHandle>;\n\n  /**\n   * **Only applicable to Bluetooth and USB readers.**\n   *\n   * Emitted when the Terminal requests that a message be displayed in your app.\n   *\n   * [*Stripe docs reference*](https://stripe.dev/stripe-terminal-android/external/com.stripe.stripeterminal.external.callable/-reader-listener/on-request-reader-display-message.html)\n   */\n  addListener(\n    eventName: TerminalEventsEnum.RequestDisplayMessage,\n    listenerFunc: ({ messageType, message }: { messageType: ReaderDisplayMessage; message: string }) => void,\n  ): Promise<PluginListenerHandle>;\n\n  /**\n   * **Only applicable to Bluetooth and USB readers.**\n   *\n   * Emitted when the reader begins waiting for input. Your app should prompt the customer\n   * to present a source using one of the given input options. If the reader emits a message,\n   * the RequestDisplayMessage event will be emitted.\n   *\n   * [*Stripe docs reference*](https://stripe.dev/stripe-terminal-android/external/com.stripe.stripeterminal.external.callable/-reader-listener/on-request-reader-input.html)\n   */\n  addListener(\n    eventName: TerminalEventsEnum.RequestReaderInput,\n    listenerFunc: ({ options, message }: { options: ReaderInputOption[]; message: string }) => void,\n  ): Promise<PluginListenerHandle>;\n\n  /**\n   * [*Stripe docs reference*](https://stripe.dev/stripe-terminal-android/external/com.stripe.stripeterminal.external.callable/-terminal-listener/on-payment-status-change.html)\n   */\n  addListener(\n    eventName: TerminalEventsEnum.PaymentStatusChange,\n    listenerFunc: ({ status }: { status: PaymentStatus }) => void,\n  ): Promise<PluginListenerHandle>;\n\n  addListener(\n    eventName: TerminalEventsEnum.ReaderReconnectStarted,\n    listenerFunc: ({ reader, reason }: { reader: ReaderInterface; reason: string }) => void,\n  ): Promise<PluginListenerHandle>;\n\n  addListener(\n    eventName: TerminalEventsEnum.ReaderReconnectSucceeded,\n    listenerFunc: ({ reader }: { reader: ReaderInterface }) => void,\n  ): Promise<PluginListenerHandle>;\n\n  addListener(\n    eventName: TerminalEventsEnum.ReaderReconnectFailed,\n    listenerFunc: ({ reader }: { reader: ReaderInterface }) => void,\n  ): Promise<PluginListenerHandle>;\n}\n"]}